// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: leave.sql

package sqlite

import (
	"context"
	"database/sql"
)

const CreateLeave = `-- name: CreateLeave :one
INSERT INTO leave_requisition (type_id, status, employee_id, director_id, reason, start_at, end_at, dock_rate)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, type_id, status, reason, start_at, end_at, dock_rate, employee_id, director_id, update_at, created_at
`

type CreateLeaveParams struct {
	TypeID     int64          `db:"type_id" json:"type_id"`
	Status     int64          `db:"status" json:"status"`
	EmployeeID sql.NullString `db:"employee_id" json:"employee_id"`
	DirectorID sql.NullString `db:"director_id" json:"director_id"`
	Reason     string         `db:"reason" json:"reason"`
	StartAt    sql.NullTime   `db:"start_at" json:"start_at"`
	EndAt      sql.NullTime   `db:"end_at" json:"end_at"`
	DockRate   sql.NullInt64  `db:"dock_rate" json:"dock_rate"`
}

func (q *Queries) CreateLeave(ctx context.Context, arg CreateLeaveParams) (LeaveRequisition, error) {
	row := q.queryRow(ctx, q.createLeaveStmt, CreateLeave,
		arg.TypeID,
		arg.Status,
		arg.EmployeeID,
		arg.DirectorID,
		arg.Reason,
		arg.StartAt,
		arg.EndAt,
		arg.DockRate,
	)
	var i LeaveRequisition
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Status,
		&i.Reason,
		&i.StartAt,
		&i.EndAt,
		&i.DockRate,
		&i.EmployeeID,
		&i.DirectorID,
		&i.UpdateAt,
		&i.CreatedAt,
	)
	return i, err
}

const CreateLeaveSuccesss = `-- name: CreateLeaveSuccesss :one
INSERT INTO leave (requisition_id, start_at, end_at)
VALUES (?, ?, ?)
RETURNING id, requisition_id, start_at, end_at
`

type CreateLeaveSuccesssParams struct {
	RequisitionID int64        `db:"requisition_id" json:"requisition_id"`
	StartAt       sql.NullTime `db:"start_at" json:"start_at"`
	EndAt         sql.NullTime `db:"end_at" json:"end_at"`
}

func (q *Queries) CreateLeaveSuccesss(ctx context.Context, arg CreateLeaveSuccesssParams) (Leave, error) {
	row := q.queryRow(ctx, q.createLeaveSuccesssStmt, CreateLeaveSuccesss, arg.RequisitionID, arg.StartAt, arg.EndAt)
	var i Leave
	err := row.Scan(
		&i.ID,
		&i.RequisitionID,
		&i.StartAt,
		&i.EndAt,
	)
	return i, err
}

const DeleteLeave = `-- name: DeleteLeave :exec
UPDATE leave_requisition
SET status = 2
WHERE id = ?
`

func (q *Queries) DeleteLeave(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteLeaveStmt, DeleteLeave, id)
	return err
}

const GetAttendanceRecord = `-- name: GetAttendanceRecord :many
SELECT  employee.name,
        lr.reason
FROM    employee 
JOIN leave_requisition AS lr ON employee.id = lr.employee_id
WHERE employee.department_id = ?
AND lr.start_at > ?
AND lr.end_at < ?
`

type GetAttendanceRecordParams struct {
	DepartmentID int64        `db:"department_id" json:"department_id"`
	StartAt      sql.NullTime `db:"start_at" json:"start_at"`
	EndAt        sql.NullTime `db:"end_at" json:"end_at"`
}

type GetAttendanceRecordRow struct {
	Name   string `db:"name" json:"name"`
	Reason string `db:"reason" json:"reason"`
}

func (q *Queries) GetAttendanceRecord(ctx context.Context, arg GetAttendanceRecordParams) ([]GetAttendanceRecordRow, error) {
	rows, err := q.query(ctx, q.getAttendanceRecordStmt, GetAttendanceRecord, arg.DepartmentID, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAttendanceRecordRow{}
	for rows.Next() {
		var i GetAttendanceRecordRow
		if err := rows.Scan(&i.Name, &i.Reason); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEmployeeListByDepartment = `-- name: GetEmployeeListByDepartment :many
SELECT  id,
        name,
        email,
        password,
        department_id
FROM    employee 
WHERE   department_id = ?
`

type GetEmployeeListByDepartmentRow struct {
	ID           string `db:"id" json:"id"`
	Name         string `db:"name" json:"name"`
	Email        string `db:"email" json:"email"`
	Password     string `db:"password" json:"password"`
	DepartmentID int64  `db:"department_id" json:"department_id"`
}

func (q *Queries) GetEmployeeListByDepartment(ctx context.Context, departmentID int64) ([]GetEmployeeListByDepartmentRow, error) {
	rows, err := q.query(ctx, q.getEmployeeListByDepartmentStmt, GetEmployeeListByDepartment, departmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEmployeeListByDepartmentRow{}
	for rows.Next() {
		var i GetEmployeeListByDepartmentRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.DepartmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLeaveByStartDate = `-- name: GetLeaveByStartDate :many
SELECT  l.start_at,
        l.end_at,
        e.name,
        lr.id
FROM leave as l
JOIN leave_requisition as lr on lr.id = l.requisition_id
JOIN employee as e on e.id = lr.employee_id
WHERE lr.status = 1
AND e.department_id = ?
AND l.start_at >= ?
AND l.start_at <= ?
`

type GetLeaveByStartDateParams struct {
	DepartmentID int64        `db:"department_id" json:"department_id"`
	StartAt      sql.NullTime `db:"start_at" json:"start_at"`
	StartAt_2    sql.NullTime `db:"start_at_2" json:"start_at_2"`
}

type GetLeaveByStartDateRow struct {
	StartAt sql.NullTime `db:"start_at" json:"start_at"`
	EndAt   sql.NullTime `db:"end_at" json:"end_at"`
	Name    string       `db:"name" json:"name"`
	ID      int64        `db:"id" json:"id"`
}

func (q *Queries) GetLeaveByStartDate(ctx context.Context, arg GetLeaveByStartDateParams) ([]GetLeaveByStartDateRow, error) {
	rows, err := q.query(ctx, q.getLeaveByStartDateStmt, GetLeaveByStartDate, arg.DepartmentID, arg.StartAt, arg.StartAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaveByStartDateRow{}
	for rows.Next() {
		var i GetLeaveByStartDateRow
		if err := rows.Scan(
			&i.StartAt,
			&i.EndAt,
			&i.Name,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLeaveListByDirectorId = `-- name: GetLeaveListByDirectorId :many
SELECT  lr.id,
        lr.type_id,
        lr.status,
        lr.employee_id,
        lr.director_id,
        lr.reason,
        lr.start_at,
        lr.end_at,
        employee.name,
        leave_type.name AS LeaveTitle
FROM    leave_requisition AS lr
JOIN employee ON lr.employee_id = employee.id
JOIN leave_type ON lr.type_id = leave_type.id
WHERE lr.director_id = ?
AND lr.status = 0
LIMIT ? OFFSET ?
`

type GetLeaveListByDirectorIdParams struct {
	DirectorID sql.NullString `db:"director_id" json:"director_id"`
	Limit      int64          `db:"limit" json:"limit"`
	Offset     int64          `db:"offset" json:"offset"`
}

type GetLeaveListByDirectorIdRow struct {
	ID         int64          `db:"id" json:"id"`
	TypeID     int64          `db:"type_id" json:"type_id"`
	Status     int64          `db:"status" json:"status"`
	EmployeeID sql.NullString `db:"employee_id" json:"employee_id"`
	DirectorID sql.NullString `db:"director_id" json:"director_id"`
	Reason     string         `db:"reason" json:"reason"`
	StartAt    sql.NullTime   `db:"start_at" json:"start_at"`
	EndAt      sql.NullTime   `db:"end_at" json:"end_at"`
	Name       string         `db:"name" json:"name"`
	LeaveTitle string         `db:"LeaveTitle" json:"LeaveTitle"`
}

func (q *Queries) GetLeaveListByDirectorId(ctx context.Context, arg GetLeaveListByDirectorIdParams) ([]GetLeaveListByDirectorIdRow, error) {
	rows, err := q.query(ctx, q.getLeaveListByDirectorIdStmt, GetLeaveListByDirectorId, arg.DirectorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaveListByDirectorIdRow{}
	for rows.Next() {
		var i GetLeaveListByDirectorIdRow
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Status,
			&i.EmployeeID,
			&i.DirectorID,
			&i.Reason,
			&i.StartAt,
			&i.EndAt,
			&i.Name,
			&i.LeaveTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLeaveListByUserId = `-- name: GetLeaveListByUserId :many
SELECT  id,
        type_id,
        status,
        employee_id,
        director_id,
        reason,
        start_at,
        end_at,
        dock_rate
FROM    leave_requisition 
WHERE   employee_id = ?
ORDER BY id DESC
LIMIT ? OFFSET ?
`

type GetLeaveListByUserIdParams struct {
	EmployeeID sql.NullString `db:"employee_id" json:"employee_id"`
	Limit      int64          `db:"limit" json:"limit"`
	Offset     int64          `db:"offset" json:"offset"`
}

type GetLeaveListByUserIdRow struct {
	ID         int64          `db:"id" json:"id"`
	TypeID     int64          `db:"type_id" json:"type_id"`
	Status     int64          `db:"status" json:"status"`
	EmployeeID sql.NullString `db:"employee_id" json:"employee_id"`
	DirectorID sql.NullString `db:"director_id" json:"director_id"`
	Reason     string         `db:"reason" json:"reason"`
	StartAt    sql.NullTime   `db:"start_at" json:"start_at"`
	EndAt      sql.NullTime   `db:"end_at" json:"end_at"`
	DockRate   sql.NullInt64  `db:"dock_rate" json:"dock_rate"`
}

func (q *Queries) GetLeaveListByUserId(ctx context.Context, arg GetLeaveListByUserIdParams) ([]GetLeaveListByUserIdRow, error) {
	rows, err := q.query(ctx, q.getLeaveListByUserIdStmt, GetLeaveListByUserId, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaveListByUserIdRow{}
	for rows.Next() {
		var i GetLeaveListByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Status,
			&i.EmployeeID,
			&i.DirectorID,
			&i.Reason,
			&i.StartAt,
			&i.EndAt,
			&i.DockRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLeaveRequisitionById = `-- name: GetLeaveRequisitionById :one
SELECT  lr.start_at,
        lr.end_at
FROM leave_requisition AS lr
WHERE lr.id = ?
`

type GetLeaveRequisitionByIdRow struct {
	StartAt sql.NullTime `db:"start_at" json:"start_at"`
	EndAt   sql.NullTime `db:"end_at" json:"end_at"`
}

func (q *Queries) GetLeaveRequisitionById(ctx context.Context, id int64) (GetLeaveRequisitionByIdRow, error) {
	row := q.queryRow(ctx, q.getLeaveRequisitionByIdStmt, GetLeaveRequisitionById, id)
	var i GetLeaveRequisitionByIdRow
	err := row.Scan(&i.StartAt, &i.EndAt)
	return i, err
}

const GetLeaveTypes = `-- name: GetLeaveTypes :many
SELECT  id,
        name,
        dock_rate
FROM    leave_type
WHERE status = 1
`

type GetLeaveTypesRow struct {
	ID       int64  `db:"id" json:"id"`
	Name     string `db:"name" json:"name"`
	DockRate int64  `db:"dock_rate" json:"dock_rate"`
}

func (q *Queries) GetLeaveTypes(ctx context.Context) ([]GetLeaveTypesRow, error) {
	rows, err := q.query(ctx, q.getLeaveTypesStmt, GetLeaveTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaveTypesRow{}
	for rows.Next() {
		var i GetLeaveTypesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.DockRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLeavesIsSuccess = `-- name: GetLeavesIsSuccess :many
SELECT  lr.reason,
        lr.start_at,
        lr.end_at,
        leave_type.name AS leaveTitle
FROM    leave_requisition AS lr
JOIN leave_type ON lr.type_id = leave_type.id
WHERE lr.employee_id = ?
AND lr.status = 1
AND lr.start_at > ?
`

type GetLeavesIsSuccessParams struct {
	EmployeeID sql.NullString `db:"employee_id" json:"employee_id"`
	StartAt    sql.NullTime   `db:"start_at" json:"start_at"`
}

type GetLeavesIsSuccessRow struct {
	Reason     string       `db:"reason" json:"reason"`
	StartAt    sql.NullTime `db:"start_at" json:"start_at"`
	EndAt      sql.NullTime `db:"end_at" json:"end_at"`
	LeaveTitle string       `db:"leaveTitle" json:"leaveTitle"`
}

func (q *Queries) GetLeavesIsSuccess(ctx context.Context, arg GetLeavesIsSuccessParams) ([]GetLeavesIsSuccessRow, error) {
	rows, err := q.query(ctx, q.getLeavesIsSuccessStmt, GetLeavesIsSuccess, arg.EmployeeID, arg.StartAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeavesIsSuccessRow{}
	for rows.Next() {
		var i GetLeavesIsSuccessRow
		if err := rows.Scan(
			&i.Reason,
			&i.StartAt,
			&i.EndAt,
			&i.LeaveTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetNationalHoliday = `-- name: GetNationalHoliday :many
SELECT  reason,
        start_at,
        end_at
FROM    leave_requisition 
WHERE   type_id = 5
`

type GetNationalHolidayRow struct {
	Reason  string       `db:"reason" json:"reason"`
	StartAt sql.NullTime `db:"start_at" json:"start_at"`
	EndAt   sql.NullTime `db:"end_at" json:"end_at"`
}

func (q *Queries) GetNationalHoliday(ctx context.Context) ([]GetNationalHolidayRow, error) {
	rows, err := q.query(ctx, q.getNationalHolidayStmt, GetNationalHoliday)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNationalHolidayRow{}
	for rows.Next() {
		var i GetNationalHolidayRow
		if err := rows.Scan(&i.Reason, &i.StartAt, &i.EndAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTotalLeaveListByDirectorId = `-- name: GetTotalLeaveListByDirectorId :one
SELECT COUNT(lr.id) AS total
FROM leave_requisition AS lr
WHERE lr.director_id = ?
AND lr.status = 0
`

func (q *Queries) GetTotalLeaveListByDirectorId(ctx context.Context, directorID sql.NullString) (int64, error) {
	row := q.queryRow(ctx, q.getTotalLeaveListByDirectorIdStmt, GetTotalLeaveListByDirectorId, directorID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const GetTotalLeaveListByEmployeeId = `-- name: GetTotalLeaveListByEmployeeId :one
SELECT COUNT(lr.id) AS total
FROM leave_requisition AS lr
WHERE lr.employee_id = ?
`

func (q *Queries) GetTotalLeaveListByEmployeeId(ctx context.Context, employeeID sql.NullString) (int64, error) {
	row := q.queryRow(ctx, q.getTotalLeaveListByEmployeeIdStmt, GetTotalLeaveListByEmployeeId, employeeID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const SreachLeaveListByStartAt = `-- name: SreachLeaveListByStartAt :many
SELECT  lr.id,
        lr.status,
        lr.employee_id,
        lr.director_id,
        lr.reason,
        lr.start_at,
        lr.end_at,
        employee.name,
        leave_type.name
FROM    leave_requisition AS lr 
JOIN employee ON lr.employee_id = employee.id
JOIN leave_type ON lr.type_id = leave_type.id
WHERE lr.start_at BETWEEN ? AND ?
`

type SreachLeaveListByStartAtParams struct {
	StartAt   sql.NullTime `db:"start_at" json:"start_at"`
	StartAt_2 sql.NullTime `db:"start_at_2" json:"start_at_2"`
}

type SreachLeaveListByStartAtRow struct {
	ID         int64          `db:"id" json:"id"`
	Status     int64          `db:"status" json:"status"`
	EmployeeID sql.NullString `db:"employee_id" json:"employee_id"`
	DirectorID sql.NullString `db:"director_id" json:"director_id"`
	Reason     string         `db:"reason" json:"reason"`
	StartAt    sql.NullTime   `db:"start_at" json:"start_at"`
	EndAt      sql.NullTime   `db:"end_at" json:"end_at"`
	Name       string         `db:"name" json:"name"`
	Name_2     string         `db:"name_2" json:"name_2"`
}

func (q *Queries) SreachLeaveListByStartAt(ctx context.Context, arg SreachLeaveListByStartAtParams) ([]SreachLeaveListByStartAtRow, error) {
	rows, err := q.query(ctx, q.sreachLeaveListByStartAtStmt, SreachLeaveListByStartAt, arg.StartAt, arg.StartAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SreachLeaveListByStartAtRow{}
	for rows.Next() {
		var i SreachLeaveListByStartAtRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.EmployeeID,
			&i.DirectorID,
			&i.Reason,
			&i.StartAt,
			&i.EndAt,
			&i.Name,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateLeave = `-- name: UpdateLeave :exec
UPDATE leave_requisition
SET status = ?
WHERE id = ?
`

type UpdateLeaveParams struct {
	Status int64 `db:"status" json:"status"`
	ID     int64 `db:"id" json:"id"`
}

func (q *Queries) UpdateLeave(ctx context.Context, arg UpdateLeaveParams) error {
	_, err := q.exec(ctx, q.updateLeaveStmt, UpdateLeave, arg.Status, arg.ID)
	return err
}
