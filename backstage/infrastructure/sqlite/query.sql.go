// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package sqlite

import (
	"context"
	"database/sql"
)

const CreateUser = `-- name: CreateUser :one
INSERT INTO employee (name, email, password, department_id, salary)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, email, password, department_id, salary, director_id, entry_at, leaved_at, update_at, created_at
`

type CreateUserParams struct {
	Name         string `db:"name" json:"name"`
	Email        string `db:"email" json:"email"`
	Password     string `db:"password" json:"password"`
	DepartmentID int64  `db:"department_id" json:"department_id"`
	Salary       int64  `db:"salary" json:"salary"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Employee, error) {
	row := q.queryRow(ctx, q.createUserStmt, CreateUser,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.DepartmentID,
		arg.Salary,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.DepartmentID,
		&i.Salary,
		&i.DirectorID,
		&i.EntryAt,
		&i.LeavedAt,
		&i.UpdateAt,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteUser = `-- name: DeleteUser :exec
UPDATE employee
SET status = 0
WHERE email = ?
`

func (q *Queries) DeleteUser(ctx context.Context, email string) error {
	_, err := q.exec(ctx, q.deleteUserStmt, DeleteUser, email)
	return err
}

const GetUserByEmail = `-- name: GetUserByEmail :one
SELECT  e.id,
        e.name,
        e.email,
        e.password,
        e.department_id,
        e.director_id,
        d.name as department_title
FROM    employee as e
JOIN    department as d ON e.department_id = d.id
WHERE   email = ?
LIMIT 1
`

type GetUserByEmailRow struct {
	ID              string         `db:"id" json:"id"`
	Name            string         `db:"name" json:"name"`
	Email           string         `db:"email" json:"email"`
	Password        string         `db:"password" json:"password"`
	DepartmentID    int64          `db:"department_id" json:"department_id"`
	DirectorID      sql.NullString `db:"director_id" json:"director_id"`
	DepartmentTitle string         `db:"department_title" json:"department_title"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, GetUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.DepartmentID,
		&i.DirectorID,
		&i.DepartmentTitle,
	)
	return i, err
}

const GetUserInfo = `-- name: GetUserInfo :one
SELECT  e.name,
        e.email,
        d.name as department_title,
        pl.total as paid_leave_total,
        pl.use as paid_leave_use
FROM    employee as e
JOIN    department as d ON e.department_id = d.id
JOIN    paid_leave as pl ON e.id = pl.employee_id
WHERE   e.id = ?
AND     pl.year = ?
LIMIT 1
`

type GetUserInfoParams struct {
	ID   string `db:"id" json:"id"`
	Year string `db:"year" json:"year"`
}

type GetUserInfoRow struct {
	Name            string `db:"name" json:"name"`
	Email           string `db:"email" json:"email"`
	DepartmentTitle string `db:"department_title" json:"department_title"`
	PaidLeaveTotal  int64  `db:"paid_leave_total" json:"paid_leave_total"`
	PaidLeaveUse    int64  `db:"paid_leave_use" json:"paid_leave_use"`
}

func (q *Queries) GetUserInfo(ctx context.Context, arg GetUserInfoParams) (GetUserInfoRow, error) {
	row := q.queryRow(ctx, q.getUserInfoStmt, GetUserInfo, arg.ID, arg.Year)
	var i GetUserInfoRow
	err := row.Scan(
		&i.Name,
		&i.Email,
		&i.DepartmentTitle,
		&i.PaidLeaveTotal,
		&i.PaidLeaveUse,
	)
	return i, err
}

const ListUserBydDepartmentId = `-- name: ListUserBydDepartmentId :many
SELECT id, name, email, password, department_id, salary, director_id, entry_at, leaved_at, update_at, created_at FROM employee
WHERE department_id = ?
ORDER BY id
`

func (q *Queries) ListUserBydDepartmentId(ctx context.Context, departmentID int64) ([]Employee, error) {
	rows, err := q.query(ctx, q.listUserBydDepartmentIdStmt, ListUserBydDepartmentId, departmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.DepartmentID,
			&i.Salary,
			&i.DirectorID,
			&i.EntryAt,
			&i.LeavedAt,
			&i.UpdateAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateName = `-- name: UpdateName :exec
UPDATE employee
SET name = ?
WHERE email = ?
`

type UpdateNameParams struct {
	Name  string `db:"name" json:"name"`
	Email string `db:"email" json:"email"`
}

func (q *Queries) UpdateName(ctx context.Context, arg UpdateNameParams) error {
	_, err := q.exec(ctx, q.updateNameStmt, UpdateName, arg.Name, arg.Email)
	return err
}
